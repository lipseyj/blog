<p>The first 4 chapters of Mythical Man Month discusses many different subjects in software engineering. The first chapter starts by explaining the struggles of the programming process and why a program is less costly than a programming system or programming product, and none are as expensive as a programming system product, but none are as effective as well. It also discusses the joys and woes of programming. The next chapter explains what a man-month(m-m) is and discusses that a lack of calendar time is the most common problem with programming and why. It also explains different situations of a task and whether adding more men will add more m-m's or can take them away. It discusses different types of partitionable or unpartitionable tasks and how adding, removing, or neither will affect the number of m-m's needed to complete the program. There are some programs where a set time will be needed no matter how many men, this is an unpartitionable task, a perfectly partitionable task defines men and months as interchangeable commodities, and a partitionable task that requires communication will be dependent on the number of men added. They even give an equation for the amount of increased effort of intercommunication for the number of people on the project(n): (n(n-1)/2). This chapter also discusses systems test and how much time should be given to each part of the project. Not that surprising to me, is that the amount of time spent testing the program is 1/2, and he also tells us that it is a general rule that testing takes up half of the time even if you don't plan for it to be that way. They also give an example of a task that is estimated to take 12 m-mâ€™s, so they assign 3 men for 4 months, but you assume that the first milepost is not complete until 2 months in. They then give multiple different scenarios in which to deal with a problem like this. Either you can assume that the time that it took will be the same for each milepost, or that the first milepost took longer for some reason and each following will follow the estimated time. Then for each situation you must add a certain number of men to get the project completed on time. This is definitely not always the best approach for all situations, you may want to reschedule or trim the task down so that it will be done on time. I also really liked that they stated Brook's Law: "Adding manpower to a late software project makes it later", which I wouldn't have necessarily thought of, but makes perfect sense when you think about m-m's wasted on training new people. The third chapter discusses a new way to build a large system, having previously discussed why small teams are better for doing programs than large teams in terms of communication, a large system will need more people because a small team simply cannot build a large system in a restricted amount of time. This new surgical team way of creating a program is called Mill's Proposal, and it states that you will have a chief programmer(surgeon) that makes all important decisions and does most of the coding. The "co-pilot" will work most with the chief programmer but is more concerned with design, discussion of program, and communication of ideas. There are many roles in this proposal of engineering including an administrator(that may be an administrator of another project depending on the size), editor(documentation), secretaries(one for admin and editor), program clerk, toolsmith, tester, and language lawyer(expert in specific language). It also discusses the difference between a conventional team of 2 programmers and a surgical team. The last chapter discusses Aristocracy, Democracy, and system design as it pertains to software engineering. I specifically liked one part where they talked about constrains allowing for new ideas and how an unconstrained implementing group will waste their time mostly on the architecture, rather than implementation, when it should be vice-versa. </p>
